; Division between 32bit fix-point numbers
; We ensure that the radix point of every number is located at the 16-th bit.
; Only dsigned for positive numbers.
; Author: Wenzhong Ou, Yu-Ming Tang
; Writen at 15th Dec, 2020.

                .global _division
_division:      .cproc dividend, divisor
                .reg result,index,cnt,
                .reg dividend_shift, divisor_shift
                .reg shift_left_max_dividend,shift_left_max_divisor

                ;Calculate how many times can dividend and divisor be shifted
                LMBD 1,dividend,shift_left_max_dividend
                LMBD 1,divisor,shift_left_max_divisor

                ZERO result
                ZERO times
                MVK 1,index

                CMPEQ divisor, 0, cnt ;test if divisor == 0
[cnt]           B label2 ;if divisor = 0. Go to branch zero_divisor. 

test_two_num:   CMPGT divisor, dividend, cnt ;test if divisor is bigger.

[cnt]           B zero_result ;if divisor > divident, go to zero_result 
                
                ;every thing's fine: dividend>=divisor and divisor != 0
                ;start to shift and minus
main_loop:
                ADD divisor_shift, 1, divisor_shift
                SHL index,1,index
                SHL divisor,1,divisor
                CMPLT divisor, dividend, cnt
[cnt]           B main_loop ; if divisor<dividend, continue looping 
                CMPEQ divisor, dividend, cnt ; else, shift enough, record result on this bit.
[cnt]           B no_remain ; if divisor=dividend, not thing remains, goto no_remain.
                
                ;deal with remains
remain_loop:
                SHR index,1,index ; Make sure dividend>divisor
                SHR divisor,1,divisor
                SUB dividend, divisor, dividend
                ;CMPLT dividend, 0, cnt

;[cnt]          ;ADD dividend, divisor, dividend ;if dividend < 0

                ADD index, result, result ; Add up to result
                CMPEQ index, 0, cnt ; if we are at the right-most bit,
[cnt]           B proc_exit ;if index = 0, go to exit 
[!cnt]          B remain_loop  ;if index != 0, back to loop2


no_remain: 
                ADD index, result, result ; Add up to result
                B proc_exit ; To return.

zero_divisor:
                MVK -1, result
                SHRU result, 1, result ; divisor = 0, result should be the largest integer

zero_result:
                CMPGT dividend_sift, shift_left_max_dividend, cnt
[!cnt]          B proc_exit 
                SHL index,1,index
                SHL dividend,1,dividend
                B test_two_num 

proc_exit:   
                .return result
                .endproc
